# cpp-spreadsheet
Дипломный проект: Электронная таблица
Представляет собой упрощённый аналог листа таблицы Excel или Google Sheets. В ячейках таблицы могут быть текст или формулы. 
Формулы могут содержать индексы ячеек. Формулы реализованы в виде деревьев. 
Для генерации кода лексического и синтаксического анализаторов применён ANTLR.

Результирующий исполняемый файл выполняет тесты в main.cpp и выводит в консоль отчёт о прохождении тестов

## Установка ANTLR
https://github.com/antlr/antlr4/blob/master/doc/getting-started.md

ANTLR - ANother Tool for Language Recognition

для windows
1. должны быть установлены python3 и JDK
2. добавить ...\local-packages\python312\scripts в переменную PATH (версию python исправить на свою `python --version`)
3. `pip install antlr4-tools`
4. добавить в переменную PATH путь до файла antlr*.jar (например C:\Java\antlr-4.13.1-complete.jar)
5. скачать и распаковать antlr4 runtime: https://www.antlr.org/download/antlr4-cpp-runtime-4.13.1-source.zip

## Создание заготовки кода с помощью ANTLR
Файл с грамматикой: ./spreadsheet/Formula.g4.

В ANTLR пользователь задаёт грамматику — правила, по которым:
- сначала формула разбивается на компоненты-токены;
- затем токены группируются в дерево разбора.

* Лексические правила в этой грамматике записаны заглавными буквами: NUMBER, ADD, SUB, MUL, DIV. Они определяют, как могут выглядеть операции и операнды, то есть на какие токены должна быть разбита строка с формулой.
* Синтаксические правила определяют, как может выглядеть выражение expr — будущий узел дерева разбора. Вариант выше по списку имеет больший приоритет.

Сгенерировать исполняемые файлы на С++: `antlr4 -Dlanguage=Cpp Formula.g4`

Что сгенерировал ANTLR:
- Formula.interp, Formula.tokens — вспомогательные текстовые файлы;
- FormulaLexer.{cpp, h} — код лексического анализатора;
- FormulaParser.{cpp, h} — код синтаксического анализатора;
- FormulaListener.{cpp, h}, FormulaBaseListener.{cpp, h} — паттерн visitor для дерева разбора. Он позволит обходить дерево разбора и строить абстрактное синтаксическое дерево для вычисления формул.
В файлах FormulaAST.h (.cpp) класс-обёртка для использования сгенерированного синтаксического анализатора

## Сборка
Такая у меня получилась структура проекта (собирал в windows):
```
> antlr4_runtime
	> cmake
	...
	> demo
	...
	> runtime
	...
	- CMakeLists.txt
	...
	- README.md
	- VERSION
> build
> dist
	- libantlr4-runtime-static.a
	- libantlr4-runtime.dll
	- libantlr4-runtime.dll.a
> вспомогательные
	- Formula.interp
	- Formula.tokens
	...
- antlr-4.13.1-complete.jar
- CMakeLists.txt
- FindANTLR.cmake
... остальные файлы из репозитория ...

```
Для сборки проекта (я использую Mingw64) выполняем команды из каталога `build`:
```
cmake ../ -G "MinGW Makefiles"
cmake --build .
```

## Описание
1. Реализован класс FormulaAST. В нём для вычисления формулы необходимо вызвать метод Execute().
Для каждого дочернего класса класса Expr (BinaryOpExpr, UnaryOpExpr, NumberExpr, CellExpr) реализован метод Evaluate(). Он вычисляет значение формулы, соответствующей дереву с вершиной в этом узле.
Для вычисления всей формулы надо вызвать Evaluate() от корня дерева.
2. Реализован класс-обёртка Formula. Он обрабатывает ошибки в формулах. (ошибки представлены классом FormulaError в файлах common.h, structures.cpp)
- Объект класса Formula создаётся в методе ParseFormula: `std::unique_ptr<FormulaInterface> ParseFormula(std::string expression);`. Если строка expression содержит синтаксически некорректную формулу, метод бросает исключение FormulaException.
- Метод `Evaluate(const SheetInterface &sheet)` вычисляет значение формулы и возвращает число, если формулу удалось вычислить. Если не удалось, возвращает ошибку вычисления FormulaError.
3. Реализован класс ячейка — Cell (CellInterface описан в файле common.h)
### Типы ячеек
Ячейки могут трактоваться как текстовые и формульные. Тип зависит от текста, который пользователь задал в методе Cell::Set().
Тип существующей ячейки может меняться, если пользователь задал в ячейке новый текст методом Set(): формульная ячейка может стать текстовой и наоборот.

Для всех типов ячеек существует два представления:
- Текст — метод GetText(). «Сырое» содержимое ячейки:
    - для текстовой ячейки — строка, которую пользователь задал в методе Set();
    - для формульной — строка, состоящая из ведущего знака "=" и строки-формулы, «очищенной» от лишних скобок.
- Значение ячейки — метод GetValue(). Может быть текстом для текстовых ячеек, числом или FormulaError для формульных.
* Формульная ячейка
Ячейка трактуется как формульная, если её текст начинается со знака "=". Пробелы перед знаком "=" не игнорируются, то есть ячейка, заданная текстом: "    =1+2", не считается формульной.
То, что следует после знака "=", называется выражением формулы — аргумент метода `std::unique_ptr<FormulaInterface> ParseFormula(std::string expression)` из файла formula.h.
- Если в методе Set() в ячейку записывают синтаксически некорректную формулу, выбрасывается исключение FormulaException,а значение ячейки не изменяется. Исключено возникновение синтаксически некорректных формул в таблице.
- метод Set() позволяет записать в ячейку формулу, которая приводит к ошибке вычисления, например "=1/0". В этом случае метод GetValue() возвращает FormulaError.
* Текстовая ячейка
Все ячейки, кроме формульных, трактуются как текстовые. Для них результат метода GetValue() совпадает с результатом метода GetText(), кроме случая, когда текст начинается с символа ' (апостроф). Тогда в GetValue() этот символ отсутствует.
Это нужно, если мы хотим начать текст со знака "=", но не хотим, чтобы он интерпретировался как формула.
4. Реализован класс лист - Sheet (SheetInterface описан в файле common.h)
Методы, обращающиеся к ячейке по индексу:
- `SetCell(Position, std::string)` задаёт содержимое ячейки по индексу Position. Если ячейка пуста, она создаётся.
- `Cell* GetCell(Position pos`) геттер, который возвращает указатель на ячейку, расположенную по индексу pos. Если ячейка пуста, возвращает nullptr;
- `void ClearCell(Position pos)` очищает ячейку по индексу. Последующий вызов GetCell() для этой ячейки вернёт nullptr. При этом может измениться размер минимальной печатной области.
- `Size GetPrintableSize()` определяет размер минимальной печатной области (количество строк и столбцов в минимальной печатной области).
Печать таблицы выводит в стандартный поток вывода std::ostream& минимальную прямоугольную печатную область. Ячейки из одной строки разделены табуляцией \t, в конце строки символ перевода строки \n.
- `void PrintText(std::ostream&)` выводит текстовые представления ячеек:
* для текстовых ячеек это текст, который пользователь задал в методе Set();
* для формульных это формула, очищенная от лишних скобок, как Formula::GetExpression(), но с ведущим знаком “=”.
- `void PrintValues(std::ostream&)` выводит значения ячеек — строки, числа или FormulaError, — как это определено в Cells::GetValue().

### Ошибки вычисления:
1 В вычислениях могут возникнуть ошибки. Если делитель равен 0, значение ячейки — ошибка FormulaError типа #ARITHM!
2 Если ячейку, чей индекс входит в формулу, нельзя проинтерпретировать как число, возникает ошибка: FormulaError — нет значения #VALUE!
3 Формула может содержать ссылку на ячейку, которая выходит за границы возможного размера таблицы, например С2 (=А1234567+ZZZZ1). Такая формула будет создана, но не может быть вычислена, поэтому её вычисление вернёт ошибку #REF!
4 Ошибки распространяются вверх по зависимостям. Если формула в С4 зависит от С2 (=С2+8). А формула в С2 выдала ошибку вычисления #VALUE! Значит, формула в С4 выдаст ту же ошибку при вычислении. Точно так же распространяются ошибки #ARITHM! и #REF! Если формула зависит от нескольких ячеек, каждая из которых содержит ошибку вычисления, результирующая ошибка может соответствовать любой из них.
5 Циклические зависимости. Таблица остаётся корректной. При попытке ввода пользователем формулы с циклической зависимостью программа бросает исключение CircularDependencyException, а ячейка не меняется.

### Требования к эффективности:
Если размер минимальной печатной области равен K, то:
1) любой метод интерфейса SheetInterface работает за O(K);
2) метод Sheet::GetCell() — за O(1);
3) метод Cell::GetValue() — за O(K);
4) метод Cell::GetText() — за O(1);
5) повторный вызов метода Cell::GetValue(), если между вызовами значения ячеек, от которых данная ячейка зависит напрямую или опосредованно, не менялись — за O(1);
6) повторный вызов метода Sheet::SetCell() с теми же аргументами — за O(1);
7) метод Cell::GetReferencedCells() возвращает индексы всех ячеек, которые входят в формулу — за O(1).

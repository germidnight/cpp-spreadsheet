# cpp-spreadsheet
Дипломный проект: Электронная таблица
/*
 * Задание 1
Реализуйте метод Execute() для класса FormulaAST, то есть «научите» дерево вычислять формулу.
Для каждого дочернего класса класса Expr реализуйте метод Evaluate(). Он вычисляет значение формулы, соответствующей дереву с вершиной в этом узле.
Тогда для вычисления всей формулы надо вызвать Evaluate() от корня дерева:
double FormulaAST::Execute() const {
    return root_expr_->Evaluate();
}
Для класса NumberExpr : Expr метод Evaluate() будет возвращать значение самого числа.
Для сложения в классе BinaryOpExpr : Expr метод должен вернуть сумму значений Evaluate() левого и правого потомков.
При вычислении может возникнуть некорректная операция, например деление на ноль или переполнение.
Чтобы это проверить подставим результат вычисления в функцию std::isfinite, которая возвращает true только если аргумент — конечное представимое число.
В этом случае функция Evaluate() должна кидать ошибку вычисления FormulaError с текстом "ARITHM". Класс FormulaError определён в файле common.h.

Обратите внимание на метод void FormulaAST::PrintFormula(std::ostream& out). Он выводит в поток формулу в «очищенном» виде, то есть без лишних скобок.
Например, формула, заданная строкой “(1+(23))”, выведется так: “1+23”. Этот метод пригодится для дальнейших заданий.

Формат входных данных:
В этом задании проверяется вычисление формул, а не их парсинг. Поэтому будем использовать только синтаксически корректные формулы, например: “1+2*3-4/5”.

Пример
Результат вычисления формулы “1+2*3-4/5” — число 6.2.
Результат вычисления формулы “1/(4-2*2)” — исключение: ошибка вычисления FormulaError.

Ограничения
Не меняйте никакие файлы кроме FormulaAST.cpp.

Реализуйте методы Evaluate() для BinaryOpExpr, UnaryOpExpr и NumberExpr в файле FormulaAST.cpp.

 * Задание 2
Теперь создайте класс-обёртку над FormulaAST и назовите его Formula.
Этот класс будет обрабатывать ошибки в формулах и подойдёт для электронной таблицы.
С ним таблица будет работать устойчиво, даже если пользователь введёт синтаксически неверную формулу либо формулу, содержащую деление на 0.
Пользуясь существующими решениями, вы, наверно, замечали, что:
1) если ввести в ячейку синтаксически некорректную формулу типа “1+-20*”, программа не позволит создать такую ячейку и выведет сообщение об ошибке.
2) можно создать синтаксически корректную формулу, которую невозможно вычислить (например “=1/(2-2)”).
Программа создаст ячейку, но в качестве значения выведет “#ARITHM!”.

В первом случае формулу не получилось создать, то есть распарсить, во втором — вычислить.
Поэтому в файле common.h созданы два типа исключений:
1) Ошибка вычисления формулы FormulaError
2) Ошибка создания формулы FormulaException

Для вашей таблицы ошибка вычисления не должна быть проблемой.
Но программа должна информировать пользователя, что формулу не удалось посчитать, и по возможности указывать причину: например деление на 0.
Реализуйте класс-обёртку над FormulaAST, который обрабатывает ошибки:
Объект класса Formula создаётся в методе ParseFormula:

std::unique_ptr<FormulaInterface> ParseFormula(std::string expression);.

Если строка expression содержит синтаксически некорректную формулу, метод должен кидать исключение FormulaException.

Метод Evaluate() должен вычислять значение формулы и возвращать число, если формулу удалось вычислить.
Если не удалось, должен возвращать ошибку вычисления FormulaError.
Для этого в файле common.h объявлен метод вывода ошибки в поток, а в файле formula.cpp он реализован.

// Возвращает вычисленное значение формулы либо ошибку. На данном этапе
// мы создали только 1 вид ошибки -- деление на 0.
using Value = std::variant<double, FormulaError>;
virtual Value Evaluate() const = 0;

В методе вывода формулы в поток GetExpression() используйте «очищенную» формулу без лишних скобок из FormulaAST::PrintFormula(std::ostream& out).
Интерфейс FormulaInterface вы найдёте в файле formula.h.

Формат входных данных
На этот раз формульные строки будут содержать в том числе синтаксически неверные формулы.

Ограничения
Не меняйте никакие файлы кроме formula.cpp.

 * Задание 3
Реализуете класс ячейка — Cell.
Ограничимся двумя типами ячеек: простой текст std::string и числа с плавающей точкой double.
Причём последние могут появиться только как результат вычисления формул.
Интерфейс класса CellInterface вы найдёте в файле common.h.

Типы ячеек
В нашей задаче ячейки могут трактоваться как текстовые и формульные. Тип зависит от текста, который пользователь задал в методе Cell::Set().
1) Ячейка формульная, если её текст начинается со знака "=". То, что следует после знака "=", называется выражением формулы.
2) Все остальные ячейки трактуются как текстовые.
Тип существующей ячейки может меняться, если пользователь задал в ячейке новый текст методом Set(): формульная ячейка может стать текстовой и наоборот.

Представление ячеек
Для всех типов ячеек существует два представления:
1) Текст — метод GetText(). «Сырое» содержимое ячейки:
    - для текстовой ячейки — строка, которую пользователь задал в методе Set();
    - для формульной — строка, состоящая из ведущего знака "=" и строки-формулы, «очищенной» от лишних скобок (вспомните метод GetExpression() класса Formula).
2) Значение ячейки — метод GetValue(). Может быть текстом для текстовых ячеек, числом или FormulaError для формульных.

Формульная ячейка
Ячейка трактуется как формульная, если её текст начинается со знака "=". Пробелы перед знаком "=" не игнорируются, то есть ячейка,
заданная текстом: "    =1+2", не считается формульной.
То, что следует после знака "=", называется выражением формулы. Именно оно — аргумент метода
std::unique_ptr<FormulaInterface> ParseFormula(std::string expression) из файла formula.h.
- Если в методе Set() в ячейку записывают синтаксически некорректную формулу, например, "=hd+2-+3((//)(112", реализация должна выбросить исключение FormulaException,
а значение ячейки не должно измениться. Это нужно, чтобы в таблице не возникло синтаксически некорректных формул.
- Однако метод Set() должен позволять записать в ячейку формулу, которая приводит к ошибке вычисления, например "=1/0".
В этом случае метод GetValue() должен возвращать FormulaError.

Текстовая ячейка
Все ячейки, кроме формульных, трактуются как текстовые. Обычно для них результат метода GetValue() совпадает с результатом метода GetText().
Кроме случая, когда текст начинается с символа ' (апостроф). Тогда в GetValue() этот символ отсутствует.
Это нужно, если мы хотим начать текст со знака "=", но не хотим, чтобы он интерпретировался как формула.
Например, ячейка задана строкой "'=1+2".
GetText() от неё "'=1+2";
GetValue() от неё "=1+2".

 * Задание 4
Реализуйте структуру данных «Электронная таблица». Интерфейс таблицы SheetInterface вы найдёте в файле common.h.
common.h содержит интерфейсы классов FormulaInterface, CellInterface, объявление структур Size и Position, описание исключений и ошибок.

Интерфейс SheetInterface не содержит методов удаления и вставки. Реализовывать их не нужно.
Для размера минимальной печатной области в файле common.h определена структура Size.
В файле  structures.cpp из решения первой задачи реализуйте operator== для этой структуры.

Методы, обращающиеся к ячейке по индексу:
- SetCell(Position, std::string) задаёт содержимое ячейки по индексу Position. Если ячейка пуста, надо её создать.
Нужно задать ячейке текст методом Cell::Set(std::string);
- Cell* GetCell(Position pos) константный и неконстантный геттеры, которые возвращают указатель на ячейку, расположенную по индексу pos.
Если ячейка пуста, возвращают nullptr;
- void ClearCell(Position pos) очищает ячейку по индексу. Последующий вызов GetCell() для этой ячейки вернёт nullptr.
При этом может измениться размер минимальной печатной области.

Методы, применимые к таблице целиком:
- Size GetPrintableSize() определяет размер минимальной печатной области. Специально для него в файле common.h и определена структура Size.
Она содержит количество строк и столбцов в минимальной печатной области.

Печать таблицы выводит в стандартный поток вывода std::ostream& минимальную прямоугольную печатную область.
Ячейки из одной строки должны быть разделены табуляцией \t, в конце строки добавьте символ перевода строки \n.

- void PrintText(std::ostream&) выводит текстовые представления ячеек:
1) для текстовых ячеек это текст, который пользователь задал в методе Set(), то есть не очищенный от ведущих апострофов ';
2) для формульных это формула, очищенная от лишних скобок, как Formula::GetExpression(), но с ведущим знаком “=”.

- void PrintValues(std::ostream&) выводит значения ячеек — строки, числа или FormulaError, — как это определено в Cells::GetValue().

Ограничения
 - Вносите изменения только в файлы sheet.h, sheet.cpp и structures.cpp. В файле structures.cpp реализуйте Size::operator==().

Требования к эффективности. Таблица должна:
- быть эффективной по памяти в случае, если таблица разрежена (большая минимальная печатная область и много пустых ячеек);
- не вызывать утечек памяти при удалении ячеек или таблицы целиком;
- предоставлять доступ к своим ячейкам по индексу Position за O(1);
- любой метод из интерфейса SheetInterface должен работать не дольше, чем за O(K), где K — размер минимальной печатной области.
Это касается и тех методов, которые только планируются: удаление и вставка столбцов/строк.

 * Задание 5
Добавим в формулы новые операнды — индексы ячеек. Формула сможет выглядеть так: “=A1*3+4/B2”.

Вычисление значений в ячейках:
Рассмотрим пример:
1) В ячейке С2 записана формула “=A3/A2”. Чтобы её вычислить, надо разделить значение ячейки А3 на значение ячейки А2.
2) В ячейке А3 находится формула “=1+2*7”. Её легко вычислить: это 15.
3) В ячейке A2 находится текст “3”. Формально ячейка не формульная. Но её текст можно интерпретировать как число. Поэтому предполагаем, что её значение 3.
4) Результат 15/3=5.
Если формула содержит индекс пустой ячейки, предполагаем, что значение пустой ячейки — 0.

Ошибки вычисления:
1) В вычислениях могут возникнуть ошибки. Если делитель равен 0, значение ячейки — ошибка FormulaError типа #ARITHM!
2) Если ячейку, чей индекс входит в формулу, нельзя проинтерпретировать как число, возникает ошибка: FormulaError — нет значения #VALUE!
3) Формула может содержать ссылку на ячейку, которая выходит за границы возможного размера таблицы, например С2 (=А1234567+ZZZZ1).
Такая формула может быть создана, но не может быть вычислена, поэтому её вычисление вернёт ошибку #REF!
4) Ошибки распространяются вверх по зависимостям. Если формула в С4 зависит от С2 (=С2+8). А формула в С2 выдала ошибку вычисления #VALUE!
Значит, формула в С4 выдаст ту же ошибку при вычислении. Точно так же распространяются ошибки #ARITHM! и #REF!
Если формула зависит от нескольких ячеек, каждая из которых содержит ошибку вычисления, результирующая ошибка может соответствовать любой из них.
5) Циклические зависимости:
Таблица должна всегда оставаться корректной. Если ячейки циклически зависят друг от друга, мы не сможем вычислить значения ячеек.
Поэтому нельзя позволить, чтобы возникли циклические зависимости между ячейками. То есть нельзя дать пользователю задать ячейку с формулой,
которая вводит циклические зависимости. Программа должна кидать исключение CircularDependencyException, а ячейка не должна меняться.

Требования к эффективности
Если размер минимальной печатной области равен K, то:
1) любой метод интерфейса SheetInterface должен работать за O(K);
2) метод Sheet::GetCell() — за O(1);
3) метод Cell::GetValue() — за O(K);
4) метод Cell::GetText() — за O(1);
5) повторный вызов метода Cell::GetValue(), если между вызовами значения ячеек, от которых данная ячейка зависит напрямую или опосредованно,
не менялись — за O(1);
6) повторный вызов метода Sheet::SetCell() с теми же аргументами — за O(1);
7) метод Cell::GetReferencedCells() возвращает индексы всех ячеек, которые входят в формулу — за O(1).
 */